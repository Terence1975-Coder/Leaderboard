import React, { useState, useEffect } from 'react';
import { 
  Copy, Search, Save, Trash2, Edit3, BookOpen, 
  Settings, Zap, Filter, Brain 
} from 'lucide-react';

// Constants
const PERSONAS = [
  'Expert Writer', 'Data Analyst', 'Creative Designer', 'Business Consultant',
  'Technical Expert', 'Marketing Specialist', 'Research Assistant', 'Content Creator',
  'Project Manager', 'Strategic Advisor'
];

const LIMITATIONS = [
  'Keep it concise', 'Use simple language', 'Avoid technical jargon',
  'Include specific examples', 'Focus on actionable insights', 'Maintain professional tone'
];

const TONES = ['Professional', 'Casual', 'Academic', 'Creative', 'Persuasive', 'Analytical', 'Humorous'];
const FORMATS = ['Paragraph', 'Bullet Points', 'Numbered List', 'Table', 'Step-by-step', 'Q&A'];
const CATEGORIES = ['Business', 'Creative', 'Technical', 'Marketing', 'Research', 'General'];

const AI_PLATFORMS = [
  { name: 'ChatGPT', url: 'https://chat.openai.com/', icon: 'ðŸ¤–' },
  { name: 'Claude', url: 'https://claude.ai/', icon: 'ðŸ§ ' },
  { name: 'Gemini', url: 'https://gemini.google.com/', icon: 'ðŸ’Ž' },
  { name: 'Perplexity', url: 'https://www.perplexity.ai/', icon: 'ðŸ”' },
  { name: 'Copilot', url: 'https://copilot.microsoft.com/', icon: 'ðŸš' },
  { name: 'Poe', url: 'https://poe.com/', icon: 'ðŸ“' }
];

// Background Component
const NeuralNetworkBackground = () => (
  <div className="absolute inset-0 overflow-hidden opacity-10">
    <svg viewBox="0 0 800 600" className="w-full h-full">
      <g>
        <circle cx="100" cy="150" r="8" fill="currentColor" className="text-cyan-400">
          <animate attributeName="opacity" values="0.3;0.8;0.3" dur="3s" repeatCount="indefinite" />
        </circle>
        <circle cx="100" cy="200" r="8" fill="currentColor" className="text-cyan-400">
          <animate attributeName="opacity" values="0.8;0.3;0.8" dur="3s" repeatCount="indefinite" />
        </circle>
        <circle cx="100" cy="250" r="8" fill="currentColor" className="text-cyan-400">
          <animate attributeName="opacity" values="0.5;0.9;0.5" dur="3s" repeatCount="indefinite" />
        </circle>
      </g>
      <g stroke="currentColor" strokeWidth="1" fill="none" className="text-slate-300">
        <line x1="108" y1="150" x2="292" y2="120" opacity="0.3">
          <animate attributeName="opacity" values="0.1;0.4;0.1" dur="3s" repeatCount="indefinite" />
        </line>
        <line x1="108" y1="200" x2="292" y2="180" opacity="0.4">
          <animate attributeName="opacity" values="0.2;0.5;0.2" dur="3s" repeatCount="indefinite" />
        </line>
      </g>
    </svg>
  </div>
);

// Header Component
const Header = () => (
  <div className="bg-gradient-to-br from-slate-800/90 to-slate-900/90 backdrop-blur-sm rounded-2xl shadow-2xl border border-slate-700/50 p-8 mb-8">
    <div className="flex items-center gap-4 mb-2">
      <div className="relative">
        <div className="p-4 bg-gradient-to-br from-cyan-500 to-purple-600 rounded-2xl shadow-lg">
          <Brain className="w-10 h-10 text-white" />
        </div>
        <div className="absolute -top-1 -right-1 w-4 h-4 bg-emerald-400 rounded-full animate-pulse"></div>
      </div>
      <div>
        <h1 className="text-4xl font-bold bg-gradient-to-r from-cyan-400 via-purple-400 to-emerald-400 bg-clip-text text-transparent">
          AI Prompt Architect
        </h1>
        <p className="text-slate-300 text-lg">
          Craft intelligent prompts with precision and creativity
        </p>
      </div>
    </div>
    
    <div className="mb-8 p-4 bg-gradient-to-r from-purple-900/30 to-cyan-900/30 rounded-xl border border-purple-500/20">
      <p className="text-center text-lg font-semibold bg-gradient-to-r from-cyan-300 to-emerald-300 bg-clip-text text-transparent">
        âœ¨ "Prompting like an expert is your AI superpower" âœ¨
      </p>
    </div>
  </div>
);

// Input Form Component
const PromptInputForm = ({ 
  request, setRequest,
  selectedPersonas, setSelectedPersonas,
  selectedLimitations, setSelectedLimitations,
  tone, setTone,
  outputFormat, setOutputFormat,
  context, setContext,
  examples, setExamples,
  wordLimit, setWordLimit,
  noWordLimit, setNoWordLimit,
  isGenerating,
  apiKey,
  onGenerate,
  onShowApiInput
}) => {
  const handlePersonaChange = (persona, checked) => {
    if (checked) {
      setSelectedPersonas([...selectedPersonas, persona]);
    } else {
      setSelectedPersonas(selectedPersonas.filter(p => p !== persona));
    }
  };

  const handleLimitationChange = (limitation, checked) => {
    if (checked) {
      setSelectedLimitations([...selectedLimitations, limitation]);
    } else {
      setSelectedLimitations(selectedLimitations.filter(l => l !== limitation));
    }
  };

  return (
    <div className="space-y-6">
      {/* Request Description */}
      <div>
        <label className="block text-sm font-semibold text-slate-200 mb-2">
          Request Description *
        </label>
        <textarea
          value={request}
          onChange={(e) => setRequest(e.target.value)}
          placeholder="Describe what you want the AI to do..."
          className="w-full h-32 p-4 bg-slate-800/50 border border-slate-600 rounded-lg focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 resize-none text-slate-100 placeholder-slate-400 backdrop-blur-sm"
        />
      </div>

      {/* Personas */}
      <div>
        <label className="block text-sm font-semibold text-slate-200 mb-2">
          Personas (Select multiple)
        </label>
        <div className="grid grid-cols-2 gap-2 max-h-40 overflow-y-auto p-3 bg-slate-800/30 border border-slate-600 rounded-lg backdrop-blur-sm">
          {PERSONAS.map(persona => (
            <label key={persona} className="flex items-center space-x-2 cursor-pointer hover:bg-slate-700/30 p-2 rounded transition-colors">
              <input
                type="checkbox"
                checked={selectedPersonas.includes(persona)}
                onChange={(e) => handlePersonaChange(persona, e.target.checked)}
                className="text-cyan-500 focus:ring-cyan-500 bg-slate-700 border-slate-600 rounded"
              />
              <span className="text-sm text-slate-300">{persona}</span>
            </label>
          ))}
        </div>
      </div>

      {/* Limitations */}
      <div>
        <label className="block text-sm font-semibold text-slate-200 mb-2">
          Guidelines & Limitations
        </label>
        <div className="grid grid-cols-1 gap-2 max-h-32 overflow-y-auto p-3 bg-slate-800/30 border border-slate-600 rounded-lg backdrop-blur-sm">
          {LIMITATIONS.map(limitation => (
            <label key={limitation} className="flex items-center space-x-2 cursor-pointer hover:bg-slate-700/30 p-2 rounded transition-colors">
              <input
                type="checkbox"
                checked={selectedLimitations.includes(limitation)}
                onChange={(e) => handleLimitationChange(limitation, e.target.checked)}
                className="text-cyan-500 focus:ring-cyan-500 bg-slate-700 border-slate-600 rounded"
              />
              <span className="text-sm text-slate-300">{limitation}</span>
            </label>
          ))}
        </div>
      </div>

      {/* Tone and Format */}
      <div className="grid grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-semibold text-slate-200 mb-2">
            Tone
          </label>
          <select
            value={tone}
            onChange={(e) => setTone(e.target.value)}
            className="w-full p-3 bg-slate-800/50 border border-slate-600 rounded-lg focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 text-slate-100 backdrop-blur-sm"
          >
            <option value="">Select tone...</option>
            {TONES.map(t => (
              <option key={t} value={t}>{t}</option>
            ))}
          </select>
        </div>

        <div>
          <label className="block text-sm font-semibold text-slate-200 mb-2">
            Output Format
          </label>
          <select
            value={outputFormat}
            onChange={(e) => setOutputFormat(e.target.value)}
            className="w-full p-3 bg-slate-800/50 border border-slate-600 rounded-lg focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 text-slate-100 backdrop-blur-sm"
          >
            <option value="">Select format...</option>
            {FORMATS.map(f => (
              <option key={f} value={f}>{f}</option>
            ))}
          </select>
        </div>
      </div>

      {/* Context */}
      <div>
        <label className="block text-sm font-semibold text-slate-200 mb-2">
          Additional Context (Optional)
        </label>
        <textarea
          value={context}
          onChange={(e) => setContext(e.target.value)}
          placeholder="Provide any additional context or background information..."
          className="w-full h-20 p-4 bg-slate-800/50 border border-slate-600 rounded-lg focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 resize-none text-slate-100 placeholder-slate-400 backdrop-blur-sm"
        />
      </div>

      {/* Examples */}
      <div>
        <label className="block text-sm font-semibold text-slate-200 mb-2">
          Examples (Optional)
        </label>
        <textarea
          value={examples}
          onChange={(e) => setExamples(e.target.value)}
          placeholder="Provide examples of desired output or style..."
          className="w-full h-20 p-4 bg-slate-800/50 border border-slate-600 rounded-lg focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 resize-none text-slate-100 placeholder-slate-400 backdrop-blur-sm"
        />
      </div>

      {/* Word Limit */}
      <div>
        <label className="block text-sm font-semibold text-slate-200 mb-2">
          Word Limit
        </label>
        <div className="flex items-center gap-4">
          <input
            type="number"
            value={wordLimit}
            onChange={(e) => setWordLimit(e.target.value)}
            disabled={noWordLimit}
            placeholder="e.g., 500"
            className="flex-1 p-3 bg-slate-800/50 border border-slate-600 rounded-lg focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 text-slate-100 placeholder-slate-400 backdrop-blur-sm disabled:opacity-50"
          />
          <label className="flex items-center space-x-2 cursor-pointer">
            <input
              type="checkbox"
              checked={noWordLimit}
              onChange={(e) => setNoWordLimit(e.target.checked)}
              className="text-cyan-500 focus:ring-cyan-500 bg-slate-700 border-slate-600 rounded"
            />
            <span className="text-sm text-slate-300">No limit</span>
          </label>
        </div>
      </div>

      {/* Generate Button */}
      <button
        onClick={onGenerate}
        disabled={!request.trim() || isGenerating}
        className="w-full bg-gradient-to-r from-cyan-500 to-purple-600 text-white py-4 px-6 rounded-lg font-semibold hover:from-cyan-600 hover:to-purple-700 disabled:from-slate-600 disabled:to-slate-700 disabled:cursor-not-allowed transition-all duration-300 flex items-center justify-center gap-2 shadow-lg hover:shadow-xl"
      >
        {isGenerating ? (
          <>
            <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white"></div>
            {apiKey ? 'AI Enhancing...' : 'Generating...'}
          </>
        ) : (
          <>
            <Zap className="w-5 h-5" />
            {apiKey ? 'Create & Enhance with AI' : 'Create Prompt'}
          </>
        )}
      </button>
      
      {/* API Key Prompt */}
      {!apiKey && (
        <div className="text-center">
          <p className="text-sm text-slate-400 mb-2">
            Want AI-enhanced prompts? 
          </p>
          <button
            onClick={onShowApiInput}
            className="text-cyan-400 hover:text-cyan-300 text-sm underline transition-colors"
          >
            Add OpenAI API Key
          </button>
        </div>
      )}
    </div>
  );
};

// Output Panel Component
const OutputPanel = ({ 
  generatedPrompt, setGeneratedPrompt,
  promptTitle, setPromptTitle,
  selectedAiPlatform, setSelectedAiPlatform,
  onCopy, onSave, onLaunch,
  isRefining, onRefine, apiKey
}) => {
  if (!generatedPrompt) return null;

  return (
    <div className="space-y-6">
      {/* Generated Prompt */}
      <div>
        <div className="flex justify-between items-center mb-2">
          <label className="block text-sm font-semibold text-slate-200">
            Generated Prompt
          </label>
          <div className="flex gap-2">
            {apiKey && (
              <button
                onClick={onRefine}
                disabled={isRefining}
                className="flex items-center gap-2 px-3 py-1 bg-purple-600/50 hover:bg-purple-600/70 rounded-lg text-sm text-slate-200 transition-colors backdrop-blur-sm border border-purple-500"
              >
                {isRefining ? (
                  <div className="animate-spin rounded-full h-3 w-3 border-b border-white"></div>
                ) : (
                  <Zap className="w-4 h-4" />
                )}
                {isRefining ? 'Refining...' : 'AI Refine'}
              </button>
            )}
            <button
              onClick={() => onCopy(generatedPrompt)}
              className="flex items-center gap-2 px-3 py-1 bg-slate-700/50 hover:bg-slate-600/50 rounded-lg text-sm text-slate-300 transition-colors backdrop-blur-sm border border-slate-600"
            >
              <Copy className="w-4 h-4" />
              Copy
            </button>
          </div>
        </div>
        <textarea
          value={generatedPrompt}
          onChange={(e) => setGeneratedPrompt(e.target.value)}
          className="w-full h-64 p-4 bg-slate-800/50 border border-slate-600 rounded-lg focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 resize-none font-mono text-sm text-slate-100 backdrop-blur-sm"
        />
      </div>

      {/* Save to Library */}
      <div>
        <label className="block text-sm font-semibold text-slate-200 mb-2">
          Save to Library
        </label>
        <div className="flex gap-2 mb-4">
          <input
            value={promptTitle}
            onChange={(e) => setPromptTitle(e.target.value)}
            placeholder="Enter prompt title..."
            className="flex-1 p-3 bg-slate-800/50 border border-slate-600 rounded-lg focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 text-slate-100 placeholder-slate-400 backdrop-blur-sm"
          />
          <button
            onClick={onSave}
            disabled={!promptTitle.trim() || !generatedPrompt.trim()}
            className="px-6 py-3 bg-gradient-to-r from-emerald-500 to-teal-600 text-white rounded-lg hover:from-emerald-600 hover:to-teal-700 disabled:from-slate-600 disabled:to-slate-700 disabled:cursor-not-allowed transition-all duration-300 shadow-lg font-semibold flex items-center gap-2"
          >
            <Save className="w-4 h-4" />
            Save
          </button>
        </div>
      </div>

      {/* Launch with AI Platform */}
      <div>
        <label className="block text-sm font-semibold text-slate-200 mb-2">
          Launch with AI Platform
        </label>
        <div className="flex gap-2">
          <select
            value={selectedAiPlatform}
            onChange={(e) => setSelectedAiPlatform(e.target.value)}
            className="flex-1 p-3 bg-slate-800/50 border border-slate-600 rounded-lg focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 text-slate-100 backdrop-blur-sm"
          >
            {AI_PLATFORMS.map(platform => (
              <option key={platform.name} value={platform.name}>
                {platform.icon} {platform.name}
              </option>
            ))}
          </select>
          <button
            onClick={onLaunch}
            disabled={!generatedPrompt.trim()}
            className="px-6 py-3 bg-gradient-to-r from-purple-500 to-pink-600 text-white rounded-lg hover:from-purple-600 hover:to-pink-700 disabled:from-slate-600 disabled:to-slate-700 disabled:cursor-not-allowed transition-all duration-300 shadow-lg font-semibold"
          >
            ðŸš€ Launch
          </button>
        </div>
        <p className="text-xs text-slate-400 mt-2">
          Prompt will be copied to clipboard and the AI platform will open in a new tab
        </p>
      </div>
    </div>
  );
};

// Library Component
const PromptLibrary = ({ 
  promptLibrary, 
  onLoad, 
  onCopy, 
  onDelete,
  editingPromptId,
  editingTitle,
  setEditingTitle,
  onStartEdit,
  onSaveEdit,
  onCancelEdit
}) => {
  return (
    <div className="bg-gradient-to-br from-slate-800/90 to-slate-900/90 backdrop-blur-sm rounded-2xl shadow-2xl border border-slate-700/50 p-8">
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-3">
          <div className="p-2 bg-gradient-to-br from-emerald-500 to-cyan-600 rounded-xl">
            <BookOpen className="w-6 h-6 text-white" />
          </div>
          <h2 className="text-2xl font-bold bg-gradient-to-r from-emerald-400 to-cyan-400 bg-clip-text text-transparent">
            Prompt Library
          </h2>
        </div>
      </div>

      {promptLibrary.length === 0 ? (
        <div className="text-center py-12 text-slate-400">
          <BookOpen className="w-16 h-16 mx-auto mb-4 text-slate-600" />
          <p>No prompts found. Create your first prompt above!</p>
        </div>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {promptLibrary.map(prompt => (
            <div key={prompt.id} className="bg-slate-800/40 border border-slate-600/50 rounded-lg p-4 hover:shadow-lg hover:border-cyan-500/50 transition-all duration-300 backdrop-blur-sm">
              {editingPromptId === prompt.id ? (
                <div className="mb-3">
                  <input
                    value={editingTitle}
                    onChange={(e) => setEditingTitle(e.target.value)}
                    className="w-full p-2 bg-slate-700 border border-slate-600 rounded text-slate-100 text-sm focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500"
                    onKeyPress={(e) => {
                      if (e.key === 'Enter') onSaveEdit(prompt.id);
                      if (e.key === 'Escape') onCancelEdit();
                    }}
                    autoFocus
                  />
                  <div className="flex gap-2 mt-2">
                    <button
                      onClick={() => onSaveEdit(prompt.id)}
                      className="px-2 py-1 bg-green-600 text-white text-xs rounded hover:bg-green-700 transition-colors"
                    >
                      Save
                    </button>
                    <button
                      onClick={onCancelEdit}
                      className="px-2 py-1 bg-slate-600 text-slate-300 text-xs rounded hover:bg-slate-700 transition-colors"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              ) : (
                <div className="flex items-center justify-between mb-2">
                  <h3 className="font-semibold text-slate-100 truncate flex-1">
                    {prompt.title}
                  </h3>
                  <button
                    onClick={() => onStartEdit(prompt.id, prompt.title)}
                    className="ml-2 p-1 text-slate-400 hover:text-slate-200 transition-colors"
                  >
                    <Edit3 className="w-4 h-4" />
                  </button>
                </div>
              )}
              
              <p className="text-sm text-slate-300 mb-3">
                {prompt.prompt.substring(0, 100)}...
              </p>
              
              <div className="flex gap-2">
                <button
                  onClick={() => onLoad(prompt)}
                  className="flex-1 px-3 py-2 bg-gradient-to-r from-cyan-500 to-purple-600 text-white text-sm rounded hover:from-cyan-600 hover:to-purple-700 transition-all duration-300 shadow-md"
                >
                  Load
                </button>
                <button
                  onClick={() => onCopy(prompt.prompt)}
                  className="px-3 py-2 bg-slate-700/50 text-slate-300 text-sm rounded hover:bg-slate-600/50 transition-colors border border-slate-600"
                >
                  <Copy className="w-4 h-4" />
                </button>
                <button
                  onClick={() => onDelete(prompt.id)}
                  className="px-3 py-2 bg-red-600/20 text-red-400 text-sm rounded hover:bg-red-600/30 transition-colors border border-red-600/50"
                >
                  <Trash2 className="w-4 h-4" />
                </button>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

// API Key Modal Component
const ApiKeyModal = ({ show, apiKey, setApiKey, onSave, onClose }) => {
  if (!show) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 backdrop-blur-sm">
      <div className="bg-slate-800 p-6 rounded-xl border border-slate-600 max-w-md w-full mx-4">
        <h3 className="text-lg font-semibold text-slate-100 mb-4">
          Enter OpenAI API Key
        </h3>
        <p className="text-sm text-slate-300 mb-4">
          To use prompt enhancement and refinement, please enter your OpenAI API key. 
          It will be stored locally in your browser.
        </p>
        <input
          type="password"
          value={apiKey}
          onChange={(e) => setApiKey(e.target.value)}
          placeholder="sk-..."
          className="w-full p-3 bg-slate-700 border border-slate-600 rounded-lg focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 text-slate-100 placeholder-slate-400 mb-4"
        />
        <div className="flex gap-2">
          <button
            onClick={onSave}
            className="flex-1 bg-gradient-to-r from-cyan-500 to-purple-600 text-white py-2 px-4 rounded-lg hover:from-cyan-600 hover:to-purple-700 transition-all duration-300"
          >
            Save & Use
          </button>
          <button
            onClick={onClose}
            className="px-4 py-2 bg-slate-700 text-slate-300 rounded-lg hover:bg-slate-600 transition-colors"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
  );
};

// Main Component
const PromptManager = () => {
  // Core state
  const [request, setRequest] = useState('');
  const [selectedPersonas, setSelectedPersonas] = useState([]);
  const [selectedLimitations, setSelectedLimitations] = useState([]);
  const [wordLimit, setWordLimit] = useState('');
  const [noWordLimit, setNoWordLimit] = useState(false);
  const [tone, setTone] = useState('');
  const [outputFormat, setOutputFormat] = useState('');
  const [context, setContext] = useState('');
  const [examples, setExamples] = useState('');
  const [generatedPrompt, setGeneratedPrompt] = useState('');
  
  // Library state
  const [promptLibrary, setPromptLibrary] = useState([]);
  const [promptTitle, setPromptTitle] = useState('');
  const [editingPromptId, setEditingPromptId] = useState(null);
  const [editingTitle, setEditingTitle] = useState('');
  
  // UI state
  const [isGenerating, setIsGenerating] = useState(false);
  const [isRefining, setIsRefining] = useState(false);
  const [showApiKeyInput, setShowApiKeyInput] = useState(false);
  
  // API state
  const [apiKey, setApiKey] = useState('');
  const [selectedAiPlatform, setSelectedAiPlatform] = useState('ChatGPT');

  // Initialize from localStorage
  useEffect(() => {
    // Load prompt library
    try {
      const saved = localStorage.getItem('promptLibrary');
      if (saved) {
        const parsed = JSON.parse(saved);
        setPromptLibrary(Array.isArray(parsed) ? parsed : []);
      }
    } catch (error) {
      console.error('Error loading prompt library:', error);
      setPromptLibrary([]);
    }

    // Load API key
    try {
      const savedApiKey = localStorage.getItem('openai_api_key');
      if (savedApiKey) {
        setApiKey(savedApiKey);
      }
    } catch (error) {
      console.error('Error loading API key:', error);
    }
  }, []);

  // Utility functions
  const copyToClipboard = async (text) => {
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text);
      } else {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
      }
    } catch (error) {
      console.error('Error copying to clipboard:', error);
    }
  };

  const buildBasicPrompt = () => {
    const components = [];
    
    if (selectedPersonas.length > 0) {
      components.push(`Acting as: ${selectedPersonas.join(', ')}`);
    }
    
    components.push(`Task: ${request.trim()}`);
    
    if (context.trim()) {
      components.push(`Context: ${context.trim()}`);
    }
    
    if (tone) {
      components.push(`Tone: ${tone}`);
    }
    
    if (outputFormat) {
      components.push(`Format: ${outputFormat}`);
    }
    
    if (selectedLimitations.length > 0) {
      components.push(`Guidelines: ${selectedLimitations.join(', ')}`);
    }
    
    if (examples.trim()) {
      components.push(`Examples: ${examples.trim()}`);
    }
    
    if (!noWordLimit && wordLimit) {
      components.push(`Word limit: ${wordLimit} words`);
    }
    
    return components.join('\n\n');
  };

  const enhanceWithApi = async (basicPrompt) => {
    if (!apiKey.trim()) return basicPrompt;

    const enhancementRequest = `Please enhance and expand this AI prompt to make it more detailed, specific, and effective. Add clear instructions, better structure, and specific guidance that will help get superior results from AI models:

"${basicPrompt}"

Make it comprehensive and professional while maintaining the original intent. Include specific examples, constraints, and detailed instructions.`;

    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey.trim()}`
        },
        body: JSON.stringify({
          model: 'gpt-3.5-turbo',
          messages: [
            {
              role: 'system',
              content: 'You are an expert prompt engineer. Your job is to enhance and expand AI prompts to make them more effective, detailed, and comprehensive.'
            },
            {
              role: 'user',
              content: enhancementRequest
            }
          ],
          max_tokens: 1500,
          temperature: 0.7
        })
      });

      if (response.ok) {
        const data = await response.json();
        return data.choices[0].message.content;
      }
    } catch (error) {
      console.error('API enhancement failed:', error);
    }
    
    return basicPrompt;
  };

  // Event handlers
  const handleGenerate = async () => {
    if (!request.trim()) return;
    
    setIsGenerating(true);
    
    try {
      const basicPrompt = buildBasicPrompt();
      const enhancedPrompt = await enhanceWithApi(basicPrompt);
      setGeneratedPrompt(enhancedPrompt);
    } catch (error) {
      console.error('Error generating prompt:', error);
      alert('Error generating prompt. Please try again.');
    } finally {
      setIsGenerating(false);
    }
  };

  const handleRefine = async () => {
    if (!apiKey.trim()) {
      setShowApiKeyInput(true);
      return;
    }

    setIsRefining(true);
    
    try {
      const refinementRequest = `Please refine and improve this AI prompt to make it more effective, clear, and comprehensive. Add specific instructions, examples, and structure that will help get better results from AI models:

"${generatedPrompt}"

Make it more professional and detailed while maintaining the original intent.`;

      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey.trim()}`
        },
        body: JSON.stringify({
          model: 'gpt-3.5-turbo',
          messages: [
            {
              role: 'system',
              content: 'You are an expert prompt engineer. Your job is to refine and improve AI prompts to make them more effective, clear, and comprehensive.'
            },
            {
              role: 'user',
              content: refinementRequest
            }
          ],
          max_tokens: 1000,
          temperature: 0.7
        })
      });

      if (response.ok) {
        const data = await response.json();
        setGeneratedPrompt(data.choices[0].message.content);
      } else {
        throw new Error('API request failed');
      }
    } catch (error) {
      console.error('Error refining prompt:', error);
      alert('Error refining prompt. Please check your API key and try again.');
    } finally {
      setIsRefining(false);
    }
  };

  const handleSaveToLibrary = () => {
    if (!promptTitle.trim() || !generatedPrompt.trim()) return;
    
    try {
      const newPrompt = {
        id: Date.now(),
        title: promptTitle.trim(),
        prompt: generatedPrompt,
        personas: selectedPersonas,
        limitations: selectedLimitations,
        category: 'General',
        createdAt: new Date().toLocaleDateString(),
        wordLimit: noWordLimit ? 'No limit' : wordLimit
      };
      
      const updated = [...promptLibrary, newPrompt];
      setPromptLibrary(updated);
      localStorage.setItem('promptLibrary', JSON.stringify(updated));
      setPromptTitle('');
    } catch (error) {
      console.error('Error saving to library:', error);
      alert('Error saving prompt to library. Please try again.');
    }
  };

  const handleLaunchWithAI = () => {
    try {
      const platform = AI_PLATFORMS.find(p => p.name === selectedAiPlatform);
      if (platform && generatedPrompt) {
        copyToClipboard(generatedPrompt);
        window.open(platform.url, '_blank');
      }
    } catch (error) {
      console.error('Error launching AI platform:', error);
    }
  };

  const handleLoadPrompt = (prompt) => {
    try {
      setGeneratedPrompt(prompt.prompt || '');
      setSelectedPersonas(prompt.personas || []);
      setSelectedLimitations(prompt.limitations || []);
      setWordLimit(prompt.wordLimit === 'No limit' ? '' : prompt.wordLimit || '');
      setNoWordLimit(prompt.wordLimit === 'No limit');
    } catch (error) {
      console.error('Error loading prompt:', error);
    }
  };

  const handleDeleteFromLibrary = (id) => {
    try {
      const updated = promptLibrary.filter(p => p.id !== id);
      setPromptLibrary(updated);
      localStorage.setItem('promptLibrary', JSON.stringify(updated));
    } catch (error) {
      console.error('Error deleting from library:', error);
    }
  };

  const handleStartEditTitle = (id, currentTitle) => {
    setEditingPromptId(id);
    setEditingTitle(currentTitle);
  };

  const handleSaveEditTitle = (id) => {
    if (!editingTitle.trim()) return;
    
    try {
      const updated = promptLibrary.map(prompt => 
        prompt.id === id ? { ...prompt, title: editingTitle.trim() } : prompt
      );
      setPromptLibrary(updated);
      localStorage.setItem('promptLibrary', JSON.stringify(updated));
      setEditingPromptId(null);
      setEditingTitle('');
    } catch (error) {
      console.error('Error saving edited title:', error);
    }
  };

  const handleCancelEditTitle = () => {
    setEditingPromptId(null);
    setEditingTitle('');
  };

  const handleSaveApiKey = () => {
    try {
      if (apiKey) {
        localStorage.setItem('openai_api_key', apiKey);
        setShowApiKeyInput(false);
      }
    } catch (error) {
      console.error('Error saving API key:', error);
      alert('Error saving API key. Please try again.');
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-6 relative">
      <NeuralNetworkBackground />
      
      <div className="max-w-7xl mx-auto relative z-10">
        <Header />
        
        {/* Main Form */}
        <div className="bg-gradient-to-br from-slate-800/90 to-slate-900/90 backdrop-blur-sm rounded-2xl shadow-2xl border border-slate-700/50 p-8 mb-8">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
            {/* Input Form */}
            <PromptInputForm
              request={request}
              setRequest={setRequest}
              selectedPersonas={selectedPersonas}
              setSelectedPersonas={setSelectedPersonas}
              selectedLimitations={selectedLimitations}
              setSelectedLimitations={setSelectedLimitations}
              tone={tone}
              setTone={setTone}
              outputFormat={outputFormat}
              setOutputFormat={setOutputFormat}
              context={context}
              setContext={setContext}
              examples={examples}
              setExamples={setExamples}
              wordLimit={wordLimit}
              setWordLimit={setWordLimit}
              noWordLimit={noWordLimit}
              setNoWordLimit={setNoWordLimit}
              isGenerating={isGenerating}
              apiKey={apiKey}
              onGenerate={handleGenerate}
              onShowApiInput={() => setShowApiKeyInput(true)}
            />

            {/* Output Panel */}
            <OutputPanel
              generatedPrompt={generatedPrompt}
              setGeneratedPrompt={setGeneratedPrompt}
              promptTitle={promptTitle}
              setPromptTitle={setPromptTitle}
              selectedAiPlatform={selectedAiPlatform}
              setSelectedAiPlatform={setSelectedAiPlatform}
              onCopy={copyToClipboard}
              onSave={handleSaveToLibrary}
              onLaunch={handleLaunchWithAI}
              isRefining={isRefining}
              onRefine={handleRefine}
              apiKey={apiKey}
            />
          </div>
        </div>

        {/* Library */}
        <PromptLibrary
          promptLibrary={promptLibrary}
          onLoad={handleLoadPrompt}
          onCopy={copyToClipboard}
          onDelete={handleDeleteFromLibrary}
          editingPromptId={editingPromptId}
          editingTitle={editingTitle}
          setEditingTitle={setEditingTitle}
          onStartEdit={handleStartEditTitle}
          onSaveEdit={handleSaveEditTitle}
          onCancelEdit={handleCancelEditTitle}
        />

        {/* API Key Modal */}
        <ApiKeyModal
          show={showApiKeyInput}
          apiKey={apiKey}
          setApiKey={setApiKey}
          onSave={handleSaveApiKey}
          onClose={() => setShowApiKeyInput(false)}
        />
      </div>
    </div>
  );
};

export default PromptManager;
